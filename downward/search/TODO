partial relaxation heuristic
============================

IDEA:

  Instead of throwing open and closed lists away after a low-level
  search step and only caching FF evaluations, consider constructing
  an explicit graph of the partially relaxed search space. Every node
  should be associated with:
  - the partially relaxed state it refers to
  - its FF evaluation, if already computed
  - its predecessor in the current evaluation round, if it was touched
    in the current evaluation round
  - pointers to its successors, if generated, labelled with the
    operator that leads to them and whether or not this is preferred
  - anything else?

  This data structure would essentially replace the current closed
  list. It would be hash-indexable to allow quickly testing if a given
  vertex is already on it. Tracing the back pointers to find the
  mid-level plan would be more efficent than the current method which
  has to do a lookup for every state in the intermediate plan.

  One question worth considering is whether additional real-state
  heuristic evaluations can be stored and used in certain cases.
  This would only make sense if these could be generated for real
  states different from the state for which the heuristic was
  requested. One maybe easily-implementable way: After computing a
  real-state estimate, trace forward along the (partially) relaxed
  plan as long as the current action does not lead to a relaxation
  (check if the action is applicable in the real state space, and if
  so, check if applying it leads to the same partially relaxed state
  as applying it in the partially relaxed state space). Every state on
  this path can be immediately assigned a real-state heuristic
  estimate of one less than the previous state.

  It feels like I'm missing some caching possibilities... it should
  also be useful to store goal distances in the *partially relaxed
  state space* in the closed graph, in case a partially relaxed state
  which has led to a goal before is encountered again later in another
  search. These would simply be graph distances.



TODO (for the heuristics):
  * Think of way of choosing set of variables to relax, and implement
    it.
  * Implement axiom computation for partially relaxed states.
    => axioms.cc

TODO (later refactorings):
  * Move to subversion.
  * Allow automatic run-time behaviour regression tests (i.e.
    it should be possible to compare runtimes for different
    svn revision numbers to one another, and get some meaningful
    statistics whether or not a change hurt or helped).
    Should support different kinds of tests, such as only comparing
    certain command line switches or certain domains, and more
    extensive tests. Should always validate generated plans.
  * Patrik's code prints statistics (time spent, expanded nodes, etc.)
    upon CTRL-C, which is neat. Implement that.
    (See hsps/stats.cc; notes:
    - abort()ing on interrupt is useful because it generates a core
      dump, if these are enabled.
    - on first CTRL-C, the interrupt handler sets a flag that will
      lead the main loop to terminate nicely and dump statistics, if
      it is responding.
    - if it is not responding, a second CTRL-C will kill the program
      immediately (see Stopwatch::interrupt_handler).
  * Integrate state space issues (state class, operator class,
    successor generation) into a single abstraction such as
    "StateSpace" and use that abstraction throughout.
  * Eliminate prevail/precondition nonsense (from *all* stages of
    translation). Requires changing .sas and .pre format... :-(
    While changing that format, add an identifier and version number
    to sas and pre files (e.g. first line "SAS", second line version
    number).
  * Check if moving from templates to class hierarchies (and
    polymorphism) is an option for OpenList, ClosedList, etc.
    This should only be done after a good mechanism for testing
    regressions wrt runtime is in place.

DONE:
  * Add (empty) new heuristic to the program.
  * Implement class for partial relaxations
    => partial_relaxation.cc
  * Implement state space for partially relaxed states.
    => partially_relaxed_state.cc, operator.cc
  * Implement successor generation for partially relaxed states.
    => successor_generator.cc
  * Templatize open lists.
    => open_list.cc
  * Templatize closed lists.
    => closed_list.cc
  * Allow computing FF estimates for partially relaxed states.
    => ff_heuristic.cc
  * Implement evaluation of partially relaxed states (best-first
    search).
    => low_level_search.cc, partial_relaxation_heuristic.cc

Notes:
* Possible state implementation: Have a state be a combination of a
  vector<int> for the non-relaxed variables and a vector<bool> for the
  relaxed ones. An index is needed to map non-relaxed state variables
  to their new int indices and relaxed variable/value pairs to their
  bool indices. This could be part of a "PartialRelaxation" class.
* A fast successor generator for partially relaxed states should first
  branch on non-relaxed states, then branch on relaxed states at the
  end.


Results
=======

NOTE: I can't reproduce those timings for p anymore... current timings
are *much* worse. I wonder why, since nothing changed apart from the
addition of cache (which shouldn't hurt) and preferred operators
(which aren't used). Hmm....

NOTE: Relaxing nothing works *very* well in Grid -- of course the
problem is basically solved after the first heuristic evaluation, so
this won't be faster than using fF, but sometimes it isn't much slower
and plan quality can be much better sometimes. This suggests a
possible any-time algorithm for improving plan quality:
  1. Find a plan.
  2. Pick an intermediate state in the plan and replan from there.
  3. Repeat.
(This algorithm works kind of like that: It finds a plan, applies the
first action, then replans. But this is only one possible variation.)


The following numbers are all for the silly "relax nothing"
intermediate relaxation. :-(

Grid domain, expansions

              f       fF        c       cC       cf     cCfF        p
prob01       59       22      405      391       83       18       32
prob02      135       42      460      317      144       71       61
prob03     9209      254  > 10000  > 10000     6904     1448      ???
prob04      587      110      519      511      396      123      128
prob05  > 10000      407  > 10000  > 10000     8879      363      ???


Grid domain, search time

              f      fF        c        cC       cf     cCfF        p
prob01     0.12     0.08     0.49     0.47     0.25     0.11     0.19
prob02     0.33     0.19     0.43     0.35     0.61     0.34     0.96
prob03    19.36     0.80      ???      ???    31.89     6.87      ???
prob04     2.17     0.73     1.69     1.77     2.95     1.16     6.65
prob05      ???     2.80      ???      ???     1:29     3.65  > 15:00


Grid domain, plan length

              f       fF        c       cC       cf     cCfF        p
prob01       14       14       14       14       14       14       14
prob02       38       31       43       44       28       31       26
prob03       85       72      ???      ???       82       63      ???
prob04       54       54       42       42       42       45       53
prob05      ???      139      ???               176      126      ???


Very good results in Zenotravel when also using preferred operators
(pP) and relaxing the non-plane variables (range != median_range in
partial_relaxation_heuristic.cc).
